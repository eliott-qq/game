#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <random>
#include <chrono>
#include <thread>
#include <iomanip>
#include <sstream>
#include <cstdlib>
#include <ctime>
#include <unistd.h>
#ifndef _WIN32
#endif

using namespace std;

// Pause (in milliseconds) after showing a failed match
static const int PAUSE_MS = 1500;

// Utility to clear the screen 
void clearScreen() {
    #ifdef _WIN32
      system("cls");
    #else
      system("clear");
    #endif
}


// Print the current board, showing revealed cards and hiding others
void printBoard(const vector<vector <string> > & board,
                const vector<vector <bool> > & revealed,int rows, int cols)
{
    cout << "    ";
    for(int c = 0; c < cols; c++)
        cout << setw(4) << c;
    cout << "\n   +" << string(cols*4, '-') << "+\n";

    for(int r = 0; r < rows; r++) {
        cout << setw(2) << r << " |";
        for(int c = 0; c < cols; c++) {
            if (revealed[r][c]) {
                cout << setw(4) << board[r][c];
            } else {
                cout << setw(4) << "*";
            }
        }
        cout << " |\n";
    }
    cout << "   +" << string(cols*4, '-') << "+\n";
}


// Prompt the user for a valid card coordinate or quit
pair<int,int> getSelection(const vector<vector<bool> > & revealed, int rows, int cols) {
    string input;
    int r, c;
    while (true) {
        cout << "Enter row and col (e.g. \"1 2\") or 'q' to quit: ";
        getline(cin, input);
        
        // Check for quit command
        if (input == "q" || input == "Q") {
            return make_pair(-1, -1); // Special value to indicate quit
        }

        // Parse input as coordinates
        istringstream iss(input);
        if (!(iss >> r >> c)) {
            cout << "Invalid input. Enter two numbers or 'q' to quit.\n";
            continue;
        }
        if (r >= 0 && r < rows && c >= 0 && c < cols) {
            if (!revealed[r][c]) {
                return make_pair(r, c);
            } else {
                cout << "That card is already revealed. Pick another.\n";
            }
        } else {
            cout << "Out of range. 0 â‰¤ row < " << rows
                 << ", 0 â‰¤ col < " << cols << ".\n";
        }
    }
}
bool getDifficultyLevel(int& rows, int& cols,int& timelimit) {
    char choice;
    while (true) {
        cout << "Choose difficulty level:\n";
        cout << "  E - Easy (4x2, 4 pairs,timelimit = 180 seconds)"<<endl;
        cout << "  M - Medium (4x4, 8 pairs,timelimit =240 seconds)"<<endl;
        cout << "  H - Hard (6x4, 12 pairs,timelimit = 250 seconds)"<<endl;                                                         
        cout << "  C - Customize (customize grid size and timelimit)"<<endl;
        cout << "Enter E, M, H or C: ";
        cin >> choice;
        choice = toupper(choice);
        if (choice == 'E') {
            rows = 4;
            cols = 2;
            timelimit = 180;
            return true;
        } else if (choice == 'M') {
            rows = 4;
            cols = 4;
            timelimit = 240;
            return true;
        } else if (choice == 'H') {
            rows = 6;
            cols = 4;
            timelimit = 250;
            return true;
        // Let user customize the grid
        } else if (choice == 'C') {
            cout << "Enter number of rows:\n";
            cin >> rows;
            cout << "Enter number of columns:\n";
            cin >> cols;
            cout << "Enter time limit in seconds:\n";
            cin >> timelimit;
            if (timelimit <=0){
                cout << "Invalid input for time limit. Please try again.\n";
                continue;
            }
            if (rows <= 0 || cols <= 0){
                cout << "Invalid input for rows or columns. Please try again.\n";
                continue;
            }
            if ((rows * cols % 2) !=0 ) {
                cout << "Error: Grid size must be even.\n";
                continue;
            }
            if (rows * cols > 38) {
                cout << "Error :Not enough fruits in the pool for the selected grid size.\n";
                cout << "Please choose a smaller grid size or add more fruits to the pool.\n";
                continue;
            }
            return true;            
        } else {
            cout << "Invalid Choice.";
        }
    }
}
// Fisher-Yates shuffle algorithm to randomize the order of elements.
void fisherYatesShuffle(std::vector<string>& vec) {
    // Seed the random number generator
    std::random_device rd;
    std::mt19937 gen(rd());
    // Shuffle the vector using the Fisher-Yates algorithm
    // Perform the Fisher-Yates shuffle
    for (size_t i = vec.size() - 1; i > 0; --i) {
        std::uniform_int_distribution<size_t> dist(0, i);
        size_t j = dist(gen);
        std::swap(vec[i], vec[j]);
    }
}
void runprogram() {
    char decision;
    // 1) Prepare a list of fruits (pair each one)
    int rows, cols;
    int timelimit;
    getDifficultyLevel(rows,cols,timelimit); 
    cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Clear newline after difficulty input
  
    // 2) Define a large pool of fruits to support various grid sizes
    vector<string> fruitPool;
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸŒ");
    fruitPool.push_back("ğŸ’");
    fruitPool.push_back("ğŸ‡");
    fruitPool.push_back("ğŸ‰");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ¥");
    fruitPool.push_back("ğŸ‘");
    fruitPool.push_back("ğŸ“");
    fruitPool.push_back("ğŸˆ");
    fruitPool.push_back("ğŸ¥­");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸŠ");
    fruitPool.push_back("ğŸ‹");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ…");
    fruitPool.push_back("ğŸ†");
    fruitPool.push_back("ğŸ¥¥");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ’");
    fruitPool.push_back("ğŸ‡");
    fruitPool.push_back("ğŸˆ");
    fruitPool.push_back("ğŸ“");
    fruitPool.push_back("ğŸ¥‘");
    fruitPool.push_back("ğŸŠ");
    fruitPool.push_back("ğŸ‹");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ‰");
    fruitPool.push_back("ğŸ¥");
    fruitPool.push_back("ğŸ†");
    fruitPool.push_back("ğŸ…");
    fruitPool.push_back("ğŸ¥­");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ¥¥");
    fruitPool.push_back("ğŸŒ");
    fruitPool.push_back("ğŸ‘");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ’");

  // Ensure the grid size is valid (even number of cards)
    if ((rows * cols) % 2 != 0) {
        cerr << "Error: Grid size (rows * cols) must be even.\n";
        return;
    }
  // Calculate pairs needed 
    const int pairsNeeded = rows * cols / 2;

  // Check if fruit pool is sufficient
   if (fruitPool.size() < pairsNeeded) {
    cerr << "Error: Fruit pool size (" << fruitPool.size() 
         << ") must be at least " << pairsNeeded << ".\n";
         return;
}

// 3) Randomly select pairsNeeded fruits
srand(static_cast<unsigned>(time(0)));
fisherYatesShuffle(fruitPool);
vector<string> selectedFruits(fruitPool.begin(), fruitPool.begin() + pairsNeeded);

// 4) Build the deck: duplicate each selected fruit and shuffle
vector<string> deck;
for (size_t i = 0; i < selectedFruits.size(); ++i) {
    deck.push_back(selectedFruits[i]);
    deck.push_back(selectedFruits[i]);
}
// Shuffle the deck to randomize card positions
fisherYatesShuffle(deck);

// 5) Lay out the board
vector<vector<string> > board(rows, vector<string>(cols));
vector<vector<bool> > revealed(rows, vector<bool>(cols, false));
int idx = 0;
for (int r = 0; r < rows; r++){
    for (int c = 0; c < cols; c++)
        board[r][c] = deck[idx++];
}
int pairsFound = 0, totalPairs = rows * cols / 2;

// Start timer
auto startTime = std::chrono::steady_clock::now();
std ::chrono::duration<double> elapsed;
// 6) Game loop
while (pairsFound < totalPairs) {
    clearScreen();
    cout << "Memory Game: find all " << totalPairs << " pairs!\n\n";
    printBoard(board, revealed, rows, cols);

    // First selection
    cout << "\nSelect first card:\n";
    pair<int,int> first = getSelection(revealed, rows, cols);
    if (first.first == -1 && first.second == -1) {
        clearScreen();
        cout << "Game quit. Thanks for playing!\n";
        return;
    }
    int r1 = first.first;
    int c1 = first.second;
    revealed[r1][c1] = true;
    clearScreen();
    printBoard(board, revealed, rows, cols);

    // Second selection
    cout << "\nSelect second card:\n";
    pair<int,int> second = getSelection(revealed, rows, cols);
    if (second.first == -1 && second.second == -1) {
        clearScreen();
        cout << "Game quit. Thanks for playing!\n";
        return;
    }
    int r2 = second.first;
    int c2 = second.second;
    revealed[r2][c2] = true;
    clearScreen();
    printBoard(board, revealed, rows, cols);

    // Check for match
    if (board[r1][c1] == board[r2][c2]) {
        cout << "\nMatched! " << board[r1][c1] << "\n";
        pairsFound++;
    } else {
        cout << "\nNot a match.\n";
        // Pause so the user can see
        cout.flush();
        #ifdef _WIN32
            Sleep(PAUSE_MS);
        #else
            usleep(PAUSE_MS * 1000);
        #endif
        // Hide them again
        revealed[r1][c1] = revealed[r2][c2] = false;
    }
    cout << "\n(Found " << pairsFound << " of " << totalPairs << " pairs.)\n";
    cout << "Press Enter to continue...";
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cin.get();

    // Stop timer
    auto endTime = std::chrono::steady_clock::now();
    elapsed = endTime - startTime;
}
clearScreen();
if (elapsed.count() >= timelimit){
cout << "Sorry. There is no time left."<< endl;
}
else{
cout << "ğŸ‰ Congratulations! You found all " << totalPairs << " pairs! ğŸ‰\n";
cout << "â±ï¸ Time taken: " << fixed << setprecision(2) << elapsed.count() << " seconds.\n";
}
} 
bool shouldrestart(){
    char decision;
    cout << "Do you want to play again? (y/n): " << endl;
    cin >> decision;
    if (decision == 'y' || decision == 'Y'){
        return true;
    }
    else if (decision == 'n' || decision == 'N'){
        cout << "Thanks for playing! Goodbye!" << endl;
        return false;
    }
    else{
        cout << "Invalid input. please enter 'y' or 'n' to continue." << endl;
        return shouldrestart();
    }
}
int main() {
    char decision;
    do {
        runprogram();
    } while (shouldrestart());
    clearScreen();
    cout <<"Program ended."<< endl;
    return 0;
}
