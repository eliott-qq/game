#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <random>
#include <chrono>
#include <thread>
#include <iomanip>
#include <sstream>
#include <cstdlib>
#include <ctime>
#include <unistd.h>
#ifndef _WIN32
#endif

using namespace std;

// Pause (in milliseconds) after showing a failed match
static const int PAUSE_MS = 1500;

// Utility to clear the screen 
void clearScreen() {
    #ifdef _WIN32
      system("cls");
    #else
      system("clear");
    #endif
}


// Print the current board, showing revealed cards and hiding others
void printBoard(const vector<vector <string> > & board,
                const vector<vector <bool> > & revealed)
{
    cout << "    ";
    for(int c = 0; c < COLS; c++)
        cout << setw(4) << c;
    cout << "\n   +" << string(COLS*4, '-') << "+\n";

    for(int r = 0; r < ROWS; r++) {
        cout << setw(2) << r << " |";
        for(int c = 0; c < COLS; c++) {
            if (revealed[r][c]) {
                cout << setw(4) << board[r][c];
            } else {
                cout << setw(4) << "*";
            }
        }
        cout << " |\n";
    }
    cout << "   +" << string(COLS*4, '-') << "+\n";
}


// Prompt the user for a valid card coordinate or quit
pair<int,int> getSelection(const vector<vector<bool> > & revealed, int rows, int cols) {
    string input;
    int r, c;
    while (true) {
        cout << "Enter row and col (e.g. \"1 2\") or 'q' to quit: ";
        getline(cin, input);
        
        // Check for quit command
        if (input == "q" || input == "Q") {
            return make_pair(-1, -1); // Special value to indicate quit
        }

        // Parse input as coordinates
        istringstream iss(input);
        if (!(iss >> r >> c)) {
            cout << "Invalid input. Enter two numbers or 'q' to quit.\n";
            continue;
        }
        if (r >= 0 && r < rows && c >= 0 && c < cols) {
            if (!revealed[r][c]) {
                return make_pair(r, c);
            } else {
                cout << "That card is already revealed. Pick another.\n";
            }
        } else {
            cout << "Out of range. 0 â‰¤ row < " << rows
                 << ", 0 â‰¤ col < " << cols << ".\n";
        }
    }
}

// Prompt user for difficulty level and set grid size
bool getDifficultyLevel(int& rows, int& cols) {
    char choice;
    while (true) {
        cout << "Choose difficulty level:\n";
        cout << "  E - Easy (4x2, 4 pairs)\n";
        cout << "  M - Medium (4x4, 8 pairs)\n";
        cout << "  H - Hard (6x4, 12 pairs)\n";
        cout << "Enter E, M, or H: ";
        cin >> choice;
        choice = toupper(choice);
        if (choice == 'E') {
            rows = 4;
            cols = 2;
            return true;
        } else if (choice == 'M') {
            rows = 4;
            cols = 4;
            return true;
        } else if (choice == 'H') {
            rows = 6;
            cols = 4;
            return true;
        } else {
            cout << "Invalid choice. Please enter E, M, or H.\n";
        }
    }
}

int main() {
    // 1) Prepare a list of fruits (pair each one)
    int ROWS, COLS;
    if (!getDifficultyLevel(ROWS, COLS)) {
        return 1;
    }
    cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Clear newline after difficulty input


    // 2) Define a large pool of fruits to support various grid sizes
    vector<string> fruitPool;
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸŒ");
    fruitPool.push_back("ğŸ’");
    fruitPool.push_back("ğŸ‡");
    fruitPool.push_back("ğŸ‰");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ¥");
    fruitPool.push_back("ğŸ‘");
    fruitPool.push_back("ğŸ“");
    fruitPool.push_back("ğŸˆ");
    fruitPool.push_back("ğŸ¥­");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸŠ");
    fruitPool.push_back("ğŸ‹");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ…");
    fruitPool.push_back("ğŸ†");
    fruitPool.push_back("ğŸ¥¥");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ’");
    fruitPool.push_back("ğŸ‡");
    fruitPool.push_back("ğŸˆ");
    fruitPool.push_back("ğŸ“");
    fruitPool.push_back("ğŸ¥‘");
    fruitPool.push_back("ğŸŠ");
    fruitPool.push_back("ğŸ‹");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ‰");
    fruitPool.push_back("ğŸ¥");
    fruitPool.push_back("ğŸ†");
    fruitPool.push_back("ğŸ…");
    fruitPool.push_back("ğŸ¥­");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ¥¥");
    fruitPool.push_back("ğŸŒ");
    fruitPool.push_back("ğŸ‘");
    fruitPool.push_back("ğŸ");
    fruitPool.push_back("ğŸ’");
    }

    // Ensure the grid size is valid (even number of cards)
    if ((ROWS * COLS) % 2 != 0) {
        cerr << "Error: Grid size (ROWS * COLS) must be even.\n";
        return 1;

    }

    const int pairsNeeded = ROWS * COLS / 2;

   // Check if fruit pool is sufficient
   if (fruitPool.size() < pairsNeeded) {
    cerr << "Error: Fruit pool size (" << fruitPool.size() 
         << ") must be at least " << pairsNeeded << ".\n";
    return 1;
}

// 3) Randomly select pairsNeeded fruits
srand((unsigned)time(NULL));
fisherYatesShuffle(fruitPool);
vector<string> selectedFruits(fruitPool.begin(), fruitPool.begin() + pairsNeeded);

// 4) Build the deck: duplicate each selected fruit and shuffle
vector<string> deck;
for (size_t i = 0; i < selectedFruits.size(); ++i) {
    deck.push_back(selectedFruits[i]);
    deck.push_back(selectedFruits[i]);
}
// Shuffle the deck to randomize card positions
fisherYatesShuffle(deck);

// 5) Lay out the board
vector<vector<string> > board(ROWS, vector<string>(COLS));
vector<vector<bool> > revealed(ROWS, vector<bool>(COLS, false));
int idx = 0;
for (int r = 0; r < ROWS; r++)
    for (int c = 0; c < COLS; c++)
        board[r][c] = deck[idx++];

int pairsFound = 0, totalPairs = ROWS * COLS / 2;

// 6) Game loop
while (pairsFound < totalPairs) {
    clearScreen();
    cout << "Memory Game: find all " << totalPairs << " pairs!\n\n";
    printBoard(board, revealed, ROWS, COLS);

    // First selection
    cout << "\nSelect first card:\n";
    pair<int,int> first = getSelection(revealed, ROWS, COLS);
    if (first.first == -1 && first.second == -1) {
        clearScreen();
        cout << "Game quit. Thanks for playing!\n";
        return 0;
    }
    int r1 = first.first;
    int c1 = first.second;
    revealed[r1][c1] = true;
    clearScreen();
    printBoard(board, revealed, ROWS, COLS);

    // Second selection
    cout << "\nSelect second card:\n";
    pair<int,int> second = getSelection(revealed, ROWS, COLS);
    if (second.first == -1 && second.second == -1) {
        clearScreen();
        cout << "Game quit. Thanks for playing!\n";
        return 0;
    }
    int r2 = second.first;
    int c2 = second.second;
    revealed[r2][c2] = true;
    clearScreen();
    printBoard(board, revealed, ROWS, COLS);

    // Check for match
    if (board[r1][c1] == board[r2][c2]) {
        cout << "\nMatched! " << board[r1][c1] << "\n";
        pairsFound++;
    } else {
        cout << "\nNot a match.\n";
        // Pause so the user can see
        cout.flush();
        #ifdef _WIN32
            Sleep(PAUSE_MS);
        #else
            usleep(PAUSE_MS * 1000);
        #endif
        // Hide them again
        revealed[r1][c1] = revealed[r2][c2] = false;
    }
    cout << "\n(Found " << pairsFound << " of " << totalPairs << " pairs.)\n";
    cout << "Press Enter to continue...";
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cin.get();
}

clearScreen();
cout << "ğŸ‰ Congratulations! You found all " << totalPairs << " pairs! ğŸ‰\n";
return 0;
}